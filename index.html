<html>

<head>
  <base href="https://retro-maze-explorer.example.com/">
  <title>bylochka</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: 'Courier New', monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>

<body>
  <div id="instructions">
  </div>
  <script>
    // Initialize Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // PSX-style settings
    renderer.setPixelRatio(0.5);
    scene.fog = new THREE.Fog(0x000000, 10, 50);

    // Texture loader
    const loader = new THREE.TextureLoader();

    // Create a ground with texture
    const groundTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
    groundTexture.wrapS = THREE.RepeatWrapping;
    groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(25, 25);
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshBasicMaterial({ map: groundTexture });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Wall texture
    const wallTexture = loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
    wallTexture.wrapS = THREE.RepeatWrapping;
    wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(1, 1);

    // Maze generation
    const mazeSize = 10;
    const roomSize = 5;
    const wallThickness = 0.5;
    const wallHeight = 3;

    function createMaze() {
      const maze = [];
      for (let i = 0; i < mazeSize; i++) {
        maze[i] = [];
        for (let j = 0; j < mazeSize; j++) {
          maze[i][j] = { north: true, east: true, south: true, west: true, visited: false };
        }
      }

      function carve(x, y) {
        maze[x][y].visited = true;
        const directions = [
          { dx: 0, dy: -1, wall: 'north' },
          { dx: 1, dy: 0, wall: 'east' },
          { dx: 0, dy: 1, wall: 'south' },
          { dx: -1, dy: 0, wall: 'west' }
        ];
        directions.sort(() => Math.random() - 0.5);

        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && !maze[nx][ny].visited) {
            maze[x][y][dir.wall] = false;
            maze[nx][ny][oppositeWall(dir.wall)] = false;
            carve(nx, ny);
          }
        }
      }

      function oppositeWall(wall) {
        switch (wall) {
          case 'north': return 'south';
          case 'east': return 'west';
          case 'south': return 'north';
          case 'west': return 'east';
        }
      }

      carve(0, 0);
      return maze;
    }

    const walls = [];

    function createWall(x, z, width, height) {
      const wallGeometry = new THREE.BoxGeometry(width, height, wallThickness);
      const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.set(x, height / 2, z);
      scene.add(wall);
      walls.push(wall);
    }

    const maze = createMaze();

    for (let i = 0; i < mazeSize; i++) {
      for (let j = 0; j < mazeSize; j++) {
        const cell = maze[i][j];
        const x = (i - mazeSize / 2) * roomSize;
        const z = (j - mazeSize / 2) * roomSize;

        if (cell.north) createWall(x, z - roomSize / 2, roomSize, wallHeight);
        if (cell.east) createWall(x + roomSize / 2, z, wallThickness, wallHeight);
        if (i === mazeSize - 1 && cell.south) createWall(x, z + roomSize / 2, roomSize, wallHeight);
        if (j === 0 && cell.west) createWall(x - roomSize / 2, z, wallThickness, wallHeight);
      }
    }

    // Add a skybox
    const skyboxTexture = loader.load('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg');
    const skyboxGeometry = new THREE.SphereGeometry(500, 60, 40);
    const skyboxMaterial = new THREE.MeshBasicMaterial({ map: skyboxTexture, side: THREE.BackSide });
    const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
    scene.add(skybox);

    // Player movement
    const moveSpeed = 0.1;
    const keys = { w: false, a: false, s: false, d: false };
    document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    camera.position.set(0, 1.6, (mazeSize / 2) * roomSize + 2); // Start position

    // Improved mouse look
    let pitch = 0;
    let yaw = 0;

    function updateCameraRotation() {
      camera.rotation.order = 'YXZ';
      camera.rotation.x = pitch;
      camera.rotation.y = yaw;
    }

    // Create entity with random texture
    const entityGeometry = new THREE.PlaneGeometry(2, 3);
    const randomImages = [
      'https://i.ytimg.com/vi/QJiosMuOsHg/mqdefault.jpg',
    
    ];
    const randomImageUrl = randomImages[Math.floor(Math.random() * randomImages.length)];
    const entityTexture = loader.load(randomImageUrl);
    const entityMaterial = new THREE.MeshBasicMaterial({ map: entityTexture, transparent: true, side: THREE.DoubleSide });
    const entity = new THREE.Mesh(entityGeometry, entityMaterial);
    entity.position.set(
      (Math.random() - 0.5) * mazeSize * roomSize,
      1.5,
      (Math.random() - 0.5) * mazeSize * roomSize
    );
    scene.add(entity);

    // Create following entity
    const followingEntityGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const followingEntityMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const followingEntity = new THREE.Mesh(followingEntityGeometry, followingEntityMaterial);
    followingEntity.position.set(
      (Math.random() - 0.5) * mazeSize * roomSize,
      1,
      (Math.random() - 0.5) * mazeSize * roomSize
    );
    scene.add(followingEntity);

    // Improved collision detection
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3();

    function checkCollision(position, moveDirection) {
      for (let i = 0; i < 4; i++) {
        direction.set(
          i === 1 ? -1 : i === 3 ? 1 : 0,
          0,
          i === 0 ? -1 : i === 2 ? 1 : 0
        );
        raycaster.set(position, direction);
        const intersects = raycaster.intersectObjects(walls);
        if (intersects.length > 0 && intersects[0].distance < 0.5) {
          return true;
        }
      }

      // Check collision with the intended move direction
      raycaster.set(position, moveDirection);
      const intersects = raycaster.intersectObjects(walls);
      return intersects.length > 0 && intersects[0].distance < 0.5;
    }

    // Function to find a valid position for the entity
    function findValidPosition(currentPosition, targetPosition) {
      const direction = new THREE.Vector3().subVectors(targetPosition, currentPosition).normalize();
      const step = 0.1;
      let newPosition = currentPosition.clone();

      for (let i = 0; i < 10; i++) { // Try up to 10 steps
        newPosition.add(direction.clone().multiplyScalar(step));
        if (!checkCollision(newPosition, direction)) {
          return newPosition;
        }
      }

      return currentPosition; // If no valid position found, return the current position
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Player movement
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      cameraDirection.y = 0; // Keep movement on the horizontal plane
      cameraDirection.normalize();
      const cameraRight = new THREE.Vector3(-cameraDirection.z, 0, cameraDirection.x);

      const moveDirection = new THREE.Vector3();
      if (keys.w) moveDirection.add(cameraDirection);
      if (keys.s) moveDirection.sub(cameraDirection);
      if (keys.a) moveDirection.sub(cameraRight);
      if (keys.d) moveDirection.add(cameraRight);
      moveDirection.normalize().multiplyScalar(moveSpeed);

      if (!checkCollision(camera.position, moveDirection)) {
        camera.position.add(moveDirection);
      }

      updateCameraRotation();

      // Entity movement
      const entityDirection = new THREE.Vector3()
        .subVectors(camera.position, entity.position)
        .normalize();
      const targetPosition = entity.position.clone().add(entityDirection.multiplyScalar(0.05));

      const newPosition = findValidPosition(entity.position, targetPosition);
      entity.position.copy(newPosition);

      entity.lookAt(camera.position);

      // Following entity movement
      const followingEntityDirection = new THREE.Vector3()
        .subVectors(camera.position, followingEntity.position)
        .normalize();
      const followingEntityTargetPosition = followingEntity.position.clone().add(followingEntityDirection.multiplyScalar(0.05));

      const followingEntityNewPosition = findValidPosition(followingEntity.position, followingEntityTargetPosition);
      followingEntity.position.copy(followingEntityNewPosition);

      renderer.render(scene, camera);
    }

    // Handle window resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

    // Lock pointer
    renderer.domElement.addEventListener('click', () => {
      renderer.domElement.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === renderer.domElement) {
        document.addEventListener('mousemove', updateMouseLook, false);
      } else {
        document.removeEventListener('mousemove', updateMouseLook, false);
      }
    });

    function updateMouseLook(e) {
      const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
      const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;

      yaw -= movementX * 0.002;
      pitch -= movementY * 0.002;

      // Clamp the pitch to prevent camera flipping
      pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
    }
  </script>
</body>

</html>
