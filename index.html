<html>

<head>
  <base href="https://websim.creativeengine.ai/hackersim/">
  <meta charset="UTF-8">
  <title>CyberVoid: скилл</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #000;
      color: #0F0;
      font-family: 'Consolas', 'Courier New', monospace;
      overflow: hidden;
    }

    #terminal {
      height: calc(100% - 60px);
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
      position: relative;
    }

    #input-line {
      display: flex;
      align-items: center;
    }

    #prompt {
      color: #0F0;
      margin-right: 5px;
    }

    #command-input {
      background-color: transparent;
      border: none;
      color: #0F0;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 14px;
      outline: none;
      width: 100%;
    }

    .output {
      margin-bottom: 5px;
    }

    #terminal::before {
      content: " ";
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      z-index: 2;
      background-size: 100% 2px, 3px 100%;
      pointer-events: none;
    }

    #terminal-header {
      background-color: #0F0;
      color: #000;
      padding: 5px 10px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header-button {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 5px;
    }

    .close {
      background-color: #FF5F56;
    }

    .minimize {
      background-color: #FFBD2E;
    }

    .maximize {
      background-color: #27C93F;
    }

    #status-bar {
      background-color: #0F0;
      color: #000;
      padding: 5px 10px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
    }

    #upgrades-menu {
      position: fixed;
      top: 50px;
      right: -300px;
      width: 280px;
      height: calc(100% - 60px);
      background-color: #001100;
      border: 2px solid #0F0;
      padding: 10px;
      transition: right 0.3s ease-in-out;
      overflow-y: auto;
    }

    #upgrades-menu.open {
      right: 10px;
    }

    .upgrade {
      border: 1px solid #0F0;
      margin-bottom: 10px;
      padding: 5px;
    }

    .upgrade h3 {
      margin: 0 0 5px 0;
    }

    .upgrade p {
      margin: 0 0 5px 0;
      font-size: 12px;
    }

    .upgrade button {
      background-color: #0F0;
      color: #000;
      border: none;
      padding: 2px 5px;
      cursor: pointer;
      font-family: 'Consolas', 'Courier New', monospace;
    }

    .upgrade button:disabled {
      background-color: #030;
      color: #060;
      cursor: not-allowed;
    }

    #missions-menu {
      position: fixed;
      top: 50px;
      right: -300px;
      width: 280px;
      height: calc(100% - 60px);
      background-color: #001100;
      border: 2px solid #0F0;
      padding: 10px;
      transition: right 0.3s ease-in-out;
      overflow-y: auto;
    }

    #missions-menu.open {
      right: 10px;
    }

    .mission {
      border: 1px solid #0F0;
      margin-bottom: 10px;
      padding: 5px;
    }

    .mission h3 {
      margin: 0 0 5px 0;
    }

    .mission p {
      margin: 0 0 5px 0;
      font-size: 12px;
    }

    .mission button {
      background-color: #0F0;
      color: #000;
      border: none;
      padding: 2px 5px;
      cursor: pointer;
      font-family: 'Consolas', 'Courier New', monospace;
    }

    .mission button:disabled {
      background-color: #030;
      color: #060;
      cursor: not-allowed;
    }

    @keyframes spin {
      0% {
        transform: rotateX(0deg) rotateY(0deg);
      }

      100% {
        transform: rotateX(360deg) rotateY(360deg);
      }
    }

    .dice {
      font-family: monospace;
      white-space: pre;
      display: inline-block;
      animation: spin 2s linear infinite;
    }
  </style>
</head>

<body>
  <div id="terminal-header">
    <span>CyberVoid Terminal</span>
    <div>
      <span class="header-button minimize"></span>
      <span class="header-button maximize"></span>
      <span class="header-button close"></span>
    </div>
  </div>
  <div id="terminal">
    <div id="output"></div>
    <div id="input-line">
      <span id="prompt">root@cybervoid:~#</span>
      <input type="text" id="command-input" autofocus>
    </div>
  </div>
  <div id="status-bar">
    <span id="balance">Баланс: 0 BTC</span>
    <span id="status">Статус: В сети</span>
  </div>
  <div id="upgrades-menu">
    <h2>Улучшения</h2>
    <div id="upgrades-list"></div>
  </div>
  <div id="missions-menu">
    <h2>Миссии</h2>
    <div id="missions-list"></div>
  </div>

  <script>
    const output = document.getElementById('output');
    const input = document.getElementById('command-input');
    const balanceElement = document.getElementById('balance');
    const upgradesMenu = document.getElementById('upgrades-menu');
    const upgradesList = document.getElementById('upgrades-list');
    const missionsMenu = document.getElementById('missions-menu');
    const missionsList = document.getElementById('missions-list');

    let balance = 0;
    let lastHackTime = 0;
    let lastMissionTime = 0;
    let hackCooldown = 25000; // 25 секунд
    let missionCooldown = 120000; // 2 минуты
    let hackSuccessChance = 0.4;
    let hackRewardMultiplier = 1;
    let criticalHackChance = 0.05;
    let detectionChance = 0.1;

    let isMissionActive = false;
    let secretPassword = '';
    let waitingForCubikBet = false;
    let waitingForCubikNumber = false;
    let cubikBet = 0;

    const upgrades = [
      {
        name: 'Улучшенный процессор',
        description: 'Увеличивает шанс успешного взлома на 2%.',
        cost: 0.1,
        effect: () => { hackSuccessChance += 0.02; },
        count: 0
      },
      {
        name: 'Расширенная память',
        description: 'Увеличивает награду за успешный взлом на 5%.',
        cost: 0.15,
        effect: () => { hackRewardMultiplier *= 1.05; },
        count: 0
      },
      {
        name: 'Квантовый алгоритм',
        description: 'Сокращает время между взломами на 1 секунду.',
        cost: 0.2,
        effect: () => { hackCooldown -= 1000; },
        count: 0
      },
      {
        name: 'Нейронная сеть',
        description: 'Увеличивает шанс критического взлома на 1%.',
        cost: 0.25,
        effect: () => { criticalHackChance += 0.01; },
        count: 0
      },
      {
        name: 'Стелс-модуль',
        description: 'Уменьшает шанс обнаружения на 2%.',
        cost: 0.3,
        effect: () => { detectionChance = Math.max(0, detectionChance - 0.02); },
        count: 0
      }
    ];

    const missions = [
      {
        name: 'Взлом сейфа с BTC',
        description: 'Попробуйте взломать защищенный сейф с криптовалютой. Каждый взлом может привести вас к секретному паролю.',
        reward: 1.0,
        startMission: () => {
          isMissionActive = true;
          secretPassword = generateSecretPassword();
          return "Миссия 'Взлом сейфа с BTC' начата. Используйте команду 'hack' для поиска секретного пароля.";
        },
        checkCompletion: (password) => {
          if (password === secretPassword) {
            isMissionActive = false;
            balance += 1.0;
            updateBalance();
            return "Поздравляем! Вы успешно взломали сейф и получили 1.0 BTC!";
          }
          return "Неверный пароль. Продолжайте поиски.";
        }
      }
    ];

    loadGameData();

    const cubeFaces = [
      [
        "  ▄▄▄▄▄  ",
        " ▐     ▌ ",
        " ▐  ●  ▌ ",
        " ▐     ▌ ",
        "  ▀▀▀▀▀  "
      ],
      [
        "  ▄▄▄▄▄  ",
        " ▐ ●   ▌ ",
        " ▐     ▌ ",
        " ▐   ● ▌ ",
        "  ▀▀▀▀▀  "
      ],
      [
        "  ▄▄▄▄▄  ",
        " ▐ ●   ▌ ",
        " ▐  ●  ▌ ",
        " ▐   ● ▌ ",
        "  ▀▀▀▀▀  "
      ],
      [
        "  ▄▄▄▄▄  ",
        " ▐ ● ● ▌ ",
        " ▐     ▌ ",
        " ▐ ● ● ▌ ",
        "  ▀▀▀▀▀  "
      ],
      [
        "  ▄▄▄▄▄  ",
        " ▐ ● ● ▌ ",
        " ▐  ●  ▌ ",
        " ▐ ● ● ▌ ",
        "  ▀▀▀▀▀  "
      ],
      [
        "  ▄▄▄▄▄  ",
        " ▐ ● ● ▌ ",
        " ▐ ● ● ▌ ",
        " ▐ ● ● ▌ ",
        "  ▀▀▀▀▀  "
      ]
    ];

    const commands = {
      help: () => 'Доступные команды: help, hack, balance, upgrades, missions, clear, cubik',
      balance: () => `Текущий баланс: ${balance.toFixed(8)} BTC`,
      upgrades: () => {
        upgradesMenu.classList.toggle('open');
        renderUpgrades();
        return 'Открыто меню улучшений.';
      },
      missions: () => {
        missionsMenu.classList.toggle('open');
        renderMissions();
        return 'Открыто меню миссий.';
      },
      clear: () => {
        output.innerHTML = '';
        return '';
      },
      hack: async () => {
        const now = Date.now();
        if (now - lastHackTime < hackCooldown) {
          const remainingTime = Math.ceil((hackCooldown - (now - lastHackTime)) / 1000);
          return `Подождите еще ${remainingTime} секунд перед следующим взломом.`;
        }

        lastHackTime = now;
        const target = generateTarget();
        let success = Math.random() < hackSuccessChance;

        await simulateHacking(target, success);

        if (success) {
          const baseReward = (Math.random() * 0.1 + 0.01);
          let reward = baseReward * hackRewardMultiplier;

          const isCritical = Math.random() < criticalHackChance;
          if (isCritical) {
            reward *= 2;
            output.innerHTML += '<div class="output">Критический взлом! Награда удвоена!</div>';
          }

          balance += reward;
          updateBalance();

          if (isMissionActive) {
            const foundPassword = Math.random() < 0.1; // 10% шанс найти пароль
            if (foundPassword) {
              return `Взлом успешен! Получено ${reward.toFixed(8)} BTC.\nВы нашли часть секретного пароля: ${secretPassword.substring(0, 3)}***`;
            }
          }

          return `Взлом успешен! Получено ${reward.toFixed(8)} BTC.`;
        } else {
          if (Math.random() < detectionChance) {
            return "Взлом не удался. Система безопасности обнаружила вторжение.";
          } else {
            return "Взлом не удался, но вам удалось избежать обнаружения.";
          }
        }
      },
      cubik: () => {
        waitingForCubikBet = true;
        return "Введите вашу ставку (не менее 0.01 BTC):";
      }
    };

    function generateTarget() {
      const ips = ['192.168.1.1', '10.0.0.1', '172.16.0.1', '8.8.8.8'];
      const organizations = ['MegaCorp', 'TechGiant', 'DataHaven', 'CyberSec'];
      return {
        ip: ips[Math.floor(Math.random() * ips.length)],
        name: organizations[Math.floor(Math.random() * organizations.length)]
      };
    }

    function generateSecretPassword() {
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < 6; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      return result;
    }

    async function simulateHacking(target, success) {
      const steps = [
        `Инициализация атаки на ${target.name} (${target.ip})...`,
        "Сканирование портов...",
        "Обнаружены уязвимости в системе безопасности...",
        "Внедрение эксплойта...",
        "Обход файервола...",
        "Получение доступа к системе...",
        "Повышение привилегий...",
        "Поиск ценных данных...",
        "Шифрование каналов связи...",
        "Скачивание данных...",
        success ? "Заметание следов..." : "Обнаружение вторжения системой безопасности!",
        "Завершение операции..."
      ];

      for (let step of steps) {
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
        const stepElement = document.createElement('div');
        stepElement.textContent = step;
        stepElement.classList.add('output');
        output.appendChild(stepElement);
        output.scrollTop = output.scrollHeight;
      }
    }

    function updateBalance() {
      balanceElement.textContent = `Баланс: ${balance.toFixed(8)} BTC`;
      saveGameData();
    }

    function saveGameData() {
      const gameData = {
        balance,
        upgrades: upgrades.map(u => u.count),
        hackSuccessChance,
        hackRewardMultiplier,
        criticalHackChance,
        detectionChance,
        hackCooldown
      };
      localStorage.setItem('hackerGameData', JSON.stringify(gameData));
    }

    function loadGameData() {
      const savedData = localStorage.getItem('hackerGameData');
      if (savedData) {
        const gameData = JSON.parse(savedData);
        balance = gameData.balance;
        hackSuccessChance = gameData.hackSuccessChance;
        hackRewardMultiplier = gameData.hackRewardMultiplier;
        criticalHackChance = gameData.criticalHackChance;
        detectionChance = gameData.detectionChance;
        hackCooldown = gameData.hackCooldown;
        upgrades.forEach((upgrade, index) => {
          upgrade.count = gameData.upgrades[index];
          for (let i = 0; i < upgrade.count; i++) {
            upgrade.effect();
          }
        });
      }
      updateBalance();
    }

    async function processInput(e) {
      if (e.key === 'Enter') {
        const cmd = input.value.toLowerCase();
        input.value = '';

        const cmdElement = document.createElement('div');
        cmdElement.textContent = `root@cybervoid:~# ${cmd}`;
        cmdElement.classList.add('output');
        output.appendChild(cmdElement);

        let result;
        if (waitingForCubikBet) {
          result = await processCubikBet(cmd);
        } else if (waitingForCubikNumber) {
          result = await processCubikNumber(cmd);
        } else if (cmd.startsWith('unlock ')) {
          const password = cmd.split(' ')[1];
          result = missions[0].checkCompletion(password);
        } else if (cmd in commands) {
          result = await commands[cmd]();
        } else {
          result = `Команда не распознана: ${cmd}. Введите 'help' для списка команд.`;
        }

        const resultElement = document.createElement('div');
        resultElement.innerHTML = result;
        resultElement.classList.add('output');
        output.appendChild(resultElement);

        output.scrollTop = output.scrollHeight;
      }
    }

    async function processCubikBet(bet) {
      waitingForCubikBet = false;
      const betAmount = parseFloat(bet);

      if (isNaN(betAmount) || betAmount < 0.01) {
        return "Неверная ставка. Минимальная ставка 0.01 BTC.";
      }

      if (betAmount > balance) {
        return "У вас недостаточно средств для этой ставки.";
      }

      cubikBet = betAmount;
      waitingForCubikNumber = true;
      return "Выберите число от 1 до 6:";
    }

    async function processCubikNumber(number) {
      waitingForCubikNumber = false;
      const chosenNumber = parseInt(number);

      if (isNaN(chosenNumber) || chosenNumber < 1 || chosenNumber > 6) {
        return "Неверное число. Выберите число от 1 до 6.";
      }

      let result = "Бросаем кубик...<br>";
      result += '<div class="dice">';

      for (let i = 0; i < 20; i++) {
        await new Promise(r => setTimeout(r, 100));
        const randomFace = Math.floor(Math.random() * 6);
        result += cubeFaces[randomFace].join('<br>') + '<br>';
      }

      const diceResult = Math.floor(Math.random() * 6) + 1;
      result += cubeFaces[diceResult - 1].join('<br>') + '</div><br>';

      if (diceResult === chosenNumber) {
        const winAmount = cubikBet * 3;
        balance += winAmount;
        updateBalance();
        result += `Поздравляем! Выпало число ${diceResult}. Вы выиграли ${winAmount.toFixed(8)} BTC!`;
      } else {
        balance -= cubikBet;
        updateBalance();
        result += `Выпало число ${diceResult}. Вы проиграли ${cubikBet.toFixed(8)} BTC.`;
      }

      return result;
    }

    function renderUpgrades() {
      upgradesList.innerHTML = '';
      upgrades.forEach((upgrade, index) => {
        const upgradeElement = document.createElement('div');
        upgradeElement.classList.add('upgrade');
        upgradeElement.innerHTML = `
      <h3>${upgrade.name}</h3>
      <p>${upgrade.description}</p>
      <p>Стоимость: ${upgrade.cost.toFixed(8)} BTC</p>
      <p>Уровень: ${upgrade.count}/5</p>
      <button onclick="buyUpgrade(${index})" ${balance < upgrade.cost || upgrade.count >= 5 ? 'disabled' : ''}>Купить</button>
    `;
        upgradesList.appendChild(upgradeElement);
      });
    }

    function buyUpgrade(index) {
      const upgrade = upgrades[index];
      if (balance >= upgrade.cost && upgrade.count < 5) {
        balance -= upgrade.cost;
        upgrade.count++;
        upgrade.effect();
        updateBalance();
        renderUpgrades();
        const resultElement = document.createElement('div');
        resultElement.textContent = `Улучшение "${upgrade.name}" приобретено.`;
        resultElement.classList.add('output');
        output.appendChild(resultElement);
        output.scrollTop = output.scrollHeight;
      }
    }

    function renderMissions() {
      missionsList.innerHTML = '';
      missions.forEach((mission, index) => {
        const missionElement = document.createElement('div');
        missionElement.classList.add('mission');
        missionElement.innerHTML = `
      <h3>${mission.name}</h3>
      <p>${mission.description}</p>
      <p>Награда: ${mission.reward.toFixed(8)} BTC</p>
      <button onclick="startMission(${index})" ${isMissionActive ? 'disabled' : ''}>Начать миссию</button>
    `;
        missionsList.appendChild(missionElement);
      });
    }

    function startMission(index) {
      const mission = missions[index];
      const resultElement = document.createElement('div');
      resultElement.textContent = mission.startMission();
      resultElement.classList.add('output');
      output.appendChild(resultElement);
      output.scrollTop = output.scrollHeight;
      renderMissions();
    }

    input.addEventListener('keypress', processInput);

    // Initial message
    const initialMessage = document.createElement('div');
    initialMessage.textContent = `Добро пожаловать в CyberVoid Hacker Simulator v2.0\nВведите 'help' для списка доступных команд.`;
    initialMessage.classList.add('output');
    output.appendChild(initialMessage);
  </script>
</body>

</html>
